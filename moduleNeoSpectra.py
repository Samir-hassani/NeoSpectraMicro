# coding: utf8
import struct
import csv
import socket
import sys
import os
import matplotlib as mpl
    # Utiliser l'affichage de l'OS pour le plot du spectre
if os.environ.get('DISPLAY','') == '':
    #print('no display found. Using non-interactive Agg backend')
    mpl.use('Agg')
import matplotlib.pyplot as plt

        # Ouvrir un socket sk(pour envoyer) et sk2(pour recevoir)
def connect():
    host = "192.168.137.2"
    write_port = 5000
    read_port = 5001

    global sk
    sk= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sk.connect((host, write_port))
    global sk2
    sk2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sk2.connect((host, read_port))

        # Operation numéro 1
        # les données doivent être des bytes codées sur 4 octets en hexadécimal en little Endian
def readModuleID():
    connect()
    print("**** readModuleID ****\n")
    Operation = bytearray([0x01,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x00,0x00,0x00,0x00])
    scanTime = bytearray([0x00,0x00,0x00,0x00])
    commonWavNum = bytearray([0x00,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
          # Paquet de données à envoyer pour exécuter la commande n°:1
    pr = Operation + resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
         # Envoie du paquet
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
         # Fermeture du socket d'envoie. S'il reste ouvert le programme tourne en boucle et le socket pour recevoir ne fonctionne pas.
    sk.close()

        # Réception des données en bytes
        # Les 4 premier octets indiquent la longueur de la donnée qu'on reçoit
    id = sk2.recv(1024)

        # Retour de la fonction pour l'envoie par Bluetooth sans la longuer
    blt = id[4:]
        # Conversion en tableau
    id = list(id)
    print("LENGTH of data : {}".format(id[0:4]))
    print("moduleID : {}".format(id[4:]))
        # Conversion de chaque octet en caractère avec un affichage sans retour à la ligne
    x = id[4:]
    for i in x:
        print(chr(i), end='')
    print(" \n")
    # Fermeture du socket réception
    sk2.close()
    return blt


        # Operation N°: 2
def checkBoard():
    connect()
    print("**** checkBoard ****\n")
    Operation = bytearray([0x02,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x00,0x00,0x00,0x00])
    scanTime = bytearray([0x00,0x00,0x00,0x00])
    commonWavNum = bytearray([0x00,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
    pr = Operation + resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(sk.send(pr)))
    sk.close()
    board = sk2.recv(1024)
    board = list(board)
    blt = board[4:]
    print("LENGTH of data : {}".format(board[0:4]))
    print("BoardStatus  : {}".format(board[4:]))
    sk2.close()
    return blt

        # Operation N°: 3
def runPSD():
    connect()
    print("**** runPSD ****\n")
    Operation = bytearray([0x03,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x03,0x00,0x00,0x00])
    scanTime = bytearray([0xD0,0x07,0x00,0x00])
    commonWavNum = bytearray([0x07,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
    pr = Operation +resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(sk.send(pr)))
    sk.close()

        # Plusieurs recv() pour recevoir la donnée en entier soit 65548 octets
    dataAll1 = sk2.recv(20480)
    dataAll2 = sk2.recv(20480)
    dataAll3 = sk2.recv(20480)
    dataAll4 = sk2.recv(20480)
    dataAll5 = sk2.recv(20480)
    dataAll6 = sk2.recv(20480)
        # concatenation de la donnée reçue
    dataAll = dataAll1 + dataAll2 + dataAll3 + dataAll4 + dataAll5 + dataAll6

    dataBytes = dataAll[12:]
    dataList = list(dataAll)
    print("LENGTH of data : {}".format(dataList[0:4]))
    print("STATUS : {}".format(dataList[4:8]))
    print("Length PSD et wavenumber : {}".format(dataList[8:12]))

        # Récuperation des valeurs de PSD, chacune est codées sur 8 octets
        # Conversion de chaque 8 octets => une valeur
    j=0
    psd = []
    for i in range(4096):
        val_1 = dataBytes[j:(j+8)]
        j+=8
        val_1 = int.from_bytes(val_1, "little")
            # Returned values are quantized. It should be divided by 2 power(33) to de-quantize them.
        val_1 /= (2**33)
        psd.append(float("%.3f"%val_1))
    psd.reverse()


        # Récuperation des valeurs de waveNumber, chacune est codées sur 8 octets
        # Conversion de chaque 8 octets => une valeur
        # Returned values are quantized. It should be divided by 2power(30) to de-quantize them.
    k = 4096*8
    wavNum = []
    for i in range(4096):
        val_2 = dataBytes[k:(k+8)]
        k+=8
        val_2 = int.from_bytes(val_2, "little")
        val_2/=(2**30)
            # Conversion de wavenumber de (cm-1) en wavelength(nm)
        val_2 = (10000000/val_2)
        wavNum.append(float("%.3f"%val_2))
    wavNum.reverse()

        # Ecriture du fichier .csv
    with open("dataRunPSD.csv", "w") as myFile:
        myFile = csv.writer(myFile)
        myFile.writerow(wavNum)
        myFile.writerow(psd)


        ## Affichge sur le graphe
#    plt.title("Spectre")
#    plt.plot(wavNum, psd)
#    plt.xlabel('Wave length')
#    plt.ylabel('PSD')
#    plt.grid(True)
#    plt.show()

    sk2.close()

        # Operation N°: 4
def runBackground():
    connect()
    print("**** runBackground ****\n")
    Operation = bytearray([0x04,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x03,0x00,0x00,0x00])
    scanTime = bytearray([0xD0,0x07,0x00,0x00])
    commonWavNum = bytearray([0x07,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])

    pr = Operation + resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(sk.send(pr)))
    sk.close()
    back = sk2.recv(1024)
    back = list(back)
    print("LENGTH of data : {}".format(back[0:4]))
    print("STATUS : {}".format(back[4:]))
    sk2.close()

        # Operation N°: 5
def runAbsorbance():
    connect()
    print("**** runAbsorbance ****\n")
    Operation = bytearray([0x05,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x03,0x00,0x00,0x00])
    scanTime = bytearray([0xD0,0x07,0x00,0x00])
    commonWavNum = bytearray([0x07,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
    pr = Operation +resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    dataAll1 = sk2.recv(20480)
    dataAll2 = sk2.recv(20480)
    dataAll3 = sk2.recv(20480)
    dataAll4 = sk2.recv(20480)
    dataAll5 = sk2.recv(20480)
    dataAll6 = sk2.recv(20480)

    dataAll = dataAll1 + dataAll2 + dataAll3 + dataAll4 + dataAll5 + dataAll6

    dataBytes = dataAll[12:]
    dataList = list(dataAll)
    print("LENGTH of data : {}".format(dataList[0:4]))
    print("STATUS : {}".format(dataList[4:8]))
    print("Length absorbance et waveNumber : {}".format(dataList[8:12]))

        # Récuperation des valeurs de Absorbance, chacune est codées sur 8 octets
        # Conversion de chaque 8 octets => une valeur
        # Returned values are quantized. It should be divided by 2 power(33) to de-quantize them.
    j=0
    absorbance = []
    for i in range(4096):
        val_1 = dataBytes[j:(j+8)]
        j+=8
        val_1 = int.from_bytes(val_1, "little")
        val_1 /= (2**33)
        absorbance.append(float("%.3f"%val_1))
    absorbance.reverse()


        # Récuperation des valeurs de waveNumber, chacune est codées sur 8 octets
        # Conversion de chaque 8 octets => une valeur
        # Returned values are quantized. It should be divided by 2 power(30) to de-quantize them.
    k = 4096*8
    wavNum = []
    for i in range(4096):
        val_2 = dataBytes[k:(k+8)]
        k+=8
        val_2 = int.from_bytes(val_2, "little")
        val_2/=(2**30)
        ## Conversion de wavenumber (cm-1) en wavelength(nm)
        val_2 = (10000000/val_2)
        wavNum.append(float("%.3f"%val_2))
    wavNum.reverse()

    # Ecriture fichier .csv
    with open("dataRunAbsorbance.csv", "w") as myFile:
        myFile = csv.writer(myFile)
        myFile.writerow(wavNum)
        myFile.writerow(absorbance)

    # Affichge sur le graphe
#    plt.title("Spectre")
#    plt.plot(wavNum, absorbance)
#    plt.xlabel('Wave length')
#    plt.ylabel('Absorbance')
#    plt.grid(True)
#    plt.show()

    sk2.close()
        # Retour de la fonction poue l'envoie par Bluetooth
    return (wavNum, absorbance)

        # Operation N°: 6
def runGainAdj():
    connect()
    print("**** runGainAdj ****\n")
    Operation = bytearray([0x06,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:5]))
    print("Gain code : {}".format(x[5:7]))
    sk2.close()

        # Operation N°: 7
def BurnGain():
    connect()
    print("**** BurnGain ****\n")
    Operation = bytearray([0x07,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 8
def BurnSelf():
    connect()
    print("**** BurnGain ****\n")
    Operation = bytearray([0x08,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 9
def runWLN():
    connect()
    print("**** runWLN ****\n")
    Operation = bytearray([0x09,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 10
def runSelfCorr():
    connect()
    print("**** runSelfCorr ****\n")
    Operation = bytearray([0x0A,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x03,0x00,0x00,0x00])
    scanTime = bytearray([0xD0,0x07,0x00,0x00])
    commonWavNum = bytearray([0x07,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
    pr = Operation +resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 11
def runWavelengthCorrBG():
    connect()
    print("**** runWavelengthCorrBG ****\n")
    Operation = bytearray([0x0B,0x00,0x00,0x00])
    resolution = bytearray([0x00,0x00,0x00,0x00])
    Mode = bytearray([0x00,0x00,0x00,0x00])
    zeroPadding = bytearray([0x03,0x00,0x00,0x00])
    scanTime = bytearray([0xD0,0x07,0x00,0x00])
    commonWavNum = bytearray([0x07,0x00,0x00,0x00])
    opticalGain = bytearray([0x00,0x00,0x00,0x00])
    apodizationSel = bytearray([0x00,0x00,0x00,0x00])
    GeneralData = bytearray([0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,\
                            0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00])
    pr = Operation +resolution + Mode + zeroPadding + scanTime + commonWavNum + opticalGain + apodizationSel + GeneralData
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 13
def restoreDefault():
    connect()
    print("**** restoreDefault ****\n")
    Operation = bytearray([0x0D,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    x = sk2.recv(1024)
    x = list(x)
    print("LENGTH of data : {}".format(x[0:4]))
    print("STATUS : {}".format(x[4:]))
    sk2.close()

        # Operation N°: 14
def readSoftwareVersion():
    connect()
    print("**** readSoftwareVersion ****\n")
    Operation = bytearray([0x0E,0x00,0x00,0x00])
    pr = Operation
    sk.send(pr)
    print("Octets envoyes : {}".format(len(pr)))
    sk.close()
    version = sk2.recv(1024)
    dvk = version[4:8]
    pi = version[8:12]
    version = list(version)
    print("LENGTH of data : {}".format(version[0:4]))
    print("DVK version : {}".format(version[4:8]))
        # coversion de chaque octet en caractère
    x = version[4:8]
    for i in x:
        print(chr(i), end=' ')
    print("\n")
    print("Pi version : {}".format(version[8:12]))
        # coversion de chaque octet en caractère
    x = version[8:12]
    for i in x:
        print(chr(i), end=' ')
    print("\n")
    sk2.close()
    return (dvk,pi)
